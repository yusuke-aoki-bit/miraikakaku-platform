taskGroups:
  - taskSpec:
      runnables:
        - container:
            imageUri: "us-central1-docker.pkg.dev/pricewise-huqkr/miraikakaku-docker/batch-stable:latest"
            entrypoint: "/bin/bash"
            commands:
              - "-c"
              - |
                echo "ğŸ” ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚«ãƒãƒ¬ãƒƒã‚¸ç¢ºèªé–‹å§‹..."
                cd /app
                
                pip install psycopg2-binary
                
                python3 -c "
                import psycopg2
                from datetime import datetime
                
                db_config = {
                    'host': '34.173.9.214',
                    'user': 'miraikakaku-user',
                    'password': 'miraikakaku-secure-pass-2024',
                    'database': 'miraikakaku',
                    'port': 5432
                }
                
                try:
                    connection = psycopg2.connect(**db_config)
                    cursor = connection.cursor()
                    print('âœ… PostgreSQLæ¥ç¶šæˆåŠŸ')
                    
                    # å„ãƒ†ãƒ¼ãƒ–ãƒ«ã®çŠ¶æ³ç¢ºèª
                    tables_to_check = ['stock_predictions', 'stock_price_history', 'stock_master']
                    
                    print('\\nğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ')
                    print('=' * 60)
                    
                    for table in tables_to_check:
                        try:
                            cursor.execute(f'SELECT COUNT(*) FROM {table}')
                            count = cursor.fetchone()[0]
                            print(f'ğŸ“‹ {table}: {count:,}ä»¶')
                            
                            if table == 'stock_predictions':
                                # äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ç¢ºèª
                                cursor.execute('''
                                    SELECT 
                                        COUNT(DISTINCT symbol) as symbols,
                                        COUNT(DISTINCT model_type) as models,
                                        MAX(prediction_horizon) as max_days,
                                        COUNT(*) as total_predictions,
                                        DATE(MAX(prediction_date)) as latest_prediction
                                    FROM stock_predictions
                                ''')
                                result = cursor.fetchone()
                                if result[0]:
                                    symbols, models, max_days, total, latest = result
                                    print(f'  â””â”€ éŠ˜æŸ„æ•°: {symbols}')
                                    print(f'  â””â”€ ãƒ¢ãƒ‡ãƒ«æ•°: {models}')
                                    print(f'  â””â”€ æœ€å¤§äºˆæ¸¬æ—¥æ•°: {max_days}æ—¥')
                                    print(f'  â””â”€ æœ€æ–°äºˆæ¸¬æ—¥: {latest}')
                                    
                                    # 180æ—¥äºˆæ¸¬ã®ç¢ºèª
                                    cursor.execute('SELECT COUNT(*) FROM stock_predictions WHERE prediction_horizon >= 180')
                                    long_term = cursor.fetchone()[0]
                                    print(f'  â””â”€ 180æ—¥äºˆæ¸¬: {long_term}ä»¶')
                            
                            elif table == 'stock_price_history':
                                # ä¾¡æ ¼å±¥æ­´ã®ç¢ºèª
                                cursor.execute('''
                                    SELECT 
                                        COUNT(DISTINCT symbol) as symbols,
                                        DATE(MIN(date)) as earliest_date,
                                        DATE(MAX(date)) as latest_date,
                                        COUNT(*) as total_records
                                    FROM stock_price_history
                                ''')
                                result = cursor.fetchone()
                                if result[0]:
                                    symbols, earliest, latest, total = result
                                    print(f'  â””â”€ éŠ˜æŸ„æ•°: {symbols}')
                                    print(f'  â””â”€ ãƒ‡ãƒ¼ã‚¿æœŸé–“: {earliest} ï½ {latest}')
                                    
                        except Exception as e:
                            print(f'âŒ {table}: ã‚¨ãƒ©ãƒ¼ - {e}')
                    
                    # ã‚«ãƒãƒ¬ãƒƒã‚¸è¨ˆç®—
                    print('\\nğŸ¯ ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æ')
                    print('-' * 40)
                    
                    # ç›®æ¨™éŠ˜æŸ„æ•°ï¼ˆåŸºæº–ï¼‰
                    target_symbols = 25  # ç›®æ¨™éŠ˜æŸ„æ•°
                    target_models = 5    # ç›®æ¨™ãƒ¢ãƒ‡ãƒ«æ•°
                    target_predictions_per_symbol = 60  # 180æ—¥äºˆæ¸¬ Ã— 5ãƒ¢ãƒ‡ãƒ« Ã— 12keyæ—¥ä»˜
                    
                    cursor.execute('SELECT COUNT(DISTINCT symbol) FROM stock_predictions')
                    current_symbols = cursor.fetchone()[0] or 0
                    
                    cursor.execute('SELECT COUNT(DISTINCT model_type) FROM stock_predictions')
                    current_models = cursor.fetchone()[0] or 0
                    
                    cursor.execute('SELECT COUNT(*) FROM stock_predictions')
                    total_predictions = cursor.fetchone()[0] or 0
                    
                    # ã‚«ãƒãƒ¬ãƒƒã‚¸ç‡è¨ˆç®—
                    symbol_coverage = min(100, (current_symbols / target_symbols) * 100)
                    model_coverage = min(100, (current_models / target_models) * 100)
                    
                    expected_total = target_symbols * target_predictions_per_symbol
                    prediction_coverage = min(100, (total_predictions / expected_total) * 100)
                    
                    overall_coverage = (symbol_coverage + model_coverage + prediction_coverage) / 3
                    
                    print(f'ğŸ“Š éŠ˜æŸ„ã‚«ãƒãƒ¬ãƒƒã‚¸: {symbol_coverage:.1f}% ({current_symbols}/{target_symbols})')
                    print(f'ğŸ¤– ãƒ¢ãƒ‡ãƒ«ã‚«ãƒãƒ¬ãƒƒã‚¸: {model_coverage:.1f}% ({current_models}/{target_models})')
                    print(f'ğŸ¯ äºˆæ¸¬ã‚«ãƒãƒ¬ãƒƒã‚¸: {prediction_coverage:.1f}% ({total_predictions:,}/{expected_total:,})')
                    print(f'\\nğŸ† ç·åˆã‚«ãƒãƒ¬ãƒƒã‚¸: {overall_coverage:.1f}%')
                    
                    if overall_coverage >= 100:
                        print('\\nğŸ‰ 100%é”æˆï¼ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è£œå¡«å®Œäº†ï¼')
                    else:
                        remaining = 100 - overall_coverage
                        print(f'\\nâ³ ã‚ã¨{remaining:.1f}%ã®è£œå¡«ãŒå¿…è¦')
                        
                        # ä¸è¶³åˆ†ã®è©³ç´°
                        print('\\nğŸ“‹ è£œå¡«ãŒå¿…è¦ãªé …ç›®:')
                        if symbol_coverage < 100:
                            needed_symbols = target_symbols - current_symbols
                            print(f'  - éŠ˜æŸ„: ã‚ã¨{needed_symbols}éŠ˜æŸ„')
                        if model_coverage < 100:
                            needed_models = target_models - current_models
                            print(f'  - ãƒ¢ãƒ‡ãƒ«: ã‚ã¨{needed_models}ãƒ¢ãƒ‡ãƒ«')
                        if prediction_coverage < 100:
                            needed_predictions = expected_total - total_predictions
                            print(f'  - äºˆæ¸¬ãƒ‡ãƒ¼ã‚¿: ã‚ã¨{needed_predictions:,}ä»¶')
                    
                    connection.close()
                    
                except Exception as e:
                    print(f'âŒ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: {e}')
                    import traceback
                    traceback.print_exc()
                "
      computeResource:
        cpuMilli: "1000"
        memoryMib: "2048"
      maxRetryCount: 1
      maxRunDuration: "300s"
    taskCount: 1
    parallelism: 1

allocationPolicy:
  instances:
    - policy:
        machineType: "e2-standard-2"
  location:
    allowedLocations:
      - "regions/us-central1"

logsPolicy:
  destination: "CLOUD_LOGGING"

labels:
  app: "miraikakaku"
  type: "db-coverage-check"
  environment: "production"