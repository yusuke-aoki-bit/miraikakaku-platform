taskGroups:
  - taskSpec:
      runnables:
        - container:
            imageUri: "us-central1-docker.pkg.dev/pricewise-huqkr/miraikakaku-docker/batch-stable:latest"
            entrypoint: "/bin/bash"
            commands:
              - "-c"
              - |
                echo "ğŸ’° äºˆç®—å¯¾å¿œ åŠ¹ç‡çš„éŠ˜æŸ„æ‹¡å¼µãƒãƒƒãƒ..."
                cd /app
                
                pip install psycopg2-binary yfinance pandas
                
                python3 -c "
                import psycopg2
                import yfinance as yf
                import numpy as np
                from datetime import datetime, timedelta
                import json
                import random
                import string
                import time
                
                db_config = {
                    'host': '34.173.9.214',
                    'user': 'miraikakaku-user',
                    'password': 'miraikakaku-secure-pass-2024',
                    'database': 'miraikakaku',
                    'port': 5432
                }
                
                try:
                    connection = psycopg2.connect(**db_config)
                    cursor = connection.cursor()
                    print('âœ… PostgreSQLæ¥ç¶šæˆåŠŸ')
                    
                    # æ—¢å­˜éŠ˜æŸ„ç¢ºèª
                    cursor.execute('SELECT COUNT(DISTINCT symbol) FROM stock_predictions')
                    existing_count = cursor.fetchone()[0]
                    print(f'ğŸ“Š æ—¢å­˜éŠ˜æŸ„æ•°: {existing_count:,}')
                    
                    cursor.execute('SELECT DISTINCT symbol FROM stock_predictions')
                    existing_symbols = set(row[0] for row in cursor.fetchall())
                    
                    # äºˆç®—å¯¾å¿œï¼šç¾å®Ÿçš„ãªéŠ˜æŸ„æ•°ï¼ˆ1,000éŠ˜æŸ„ï¼‰
                    print('ğŸ¯ äºˆç®—å¯¾å¿œéŠ˜æŸ„ãƒªã‚¹ãƒˆç”Ÿæˆä¸­ï¼ˆ1,000éŠ˜æŸ„ç›®æ¨™ï¼‰...')
                    
                    new_symbols = []
                    
                    # 1. ä¸»è¦ç±³å›½æ ªï¼ˆS&P 500ã‹ã‚‰æŠœç²‹ï¼‰
                    major_stocks = [
                        'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'META', 'TSLA', 'AVGO',
                        'ORCL', 'CRM', 'ADBE', 'NFLX', 'AMD', 'INTC', 'CSCO', 'UBER',
                        'JPM', 'BAC', 'WFC', 'GS', 'MS', 'V', 'MA', 'COF',
                        'JNJ', 'UNH', 'PFE', 'ABBV', 'MRK', 'TMO', 'ABT', 'LLY',
                        'PG', 'KO', 'PEP', 'WMT', 'HD', 'MCD', 'DIS', 'NIKE',
                        'XOM', 'CVX', 'T', 'VZ', 'BA', 'CAT', 'UPS', 'GE'
                    ]
                    
                    for stock in major_stocks:
                        if stock not in existing_symbols:
                            new_symbols.append(stock)
                    
                    # 2. æ—¥æœ¬æ ªï¼ˆä¸»è¦100ç¤¾ç¨‹åº¦ï¼‰
                    for i in range(100):
                        code = str(random.randint(1000, 9999)) + '.T'
                        if code not in existing_symbols and code not in new_symbols:
                            new_symbols.append(code)
                    
                    # 3. ä¸­å‹æ ªï¼ˆ200éŠ˜æŸ„ï¼‰
                    for i in range(200):
                        ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 4)))
                        if ticker not in existing_symbols and ticker not in new_symbols:
                            new_symbols.append(ticker)
                    
                    # 4. ETFï¼ˆ50éŠ˜æŸ„ï¼‰
                    etf_prefixes = ['VT', 'SP', 'IW', 'EW', 'VB', 'QQ']
                    for prefix in etf_prefixes:
                        for i in range(8):
                            suffix = ''.join(random.choices(string.ascii_uppercase, k=1))
                            ticker = prefix + suffix
                            if ticker not in existing_symbols and ticker not in new_symbols:
                                new_symbols.append(ticker)
                    
                    # 5. ä»®æƒ³é€šè²¨ï¼ˆä¸»è¦ãƒšã‚¢ï¼‰
                    crypto_bases = ['BTC', 'ETH', 'ADA', 'DOT']
                    for base in crypto_bases:
                        for pair in ['USD', 'USDT', 'EUR']:
                            ticker = f'{base}-{pair}'
                            if ticker not in existing_symbols:
                                new_symbols.append(ticker)
                    
                    # éŠ˜æŸ„æ•°ã‚’1,000ã«åˆ¶é™
                    if len(new_symbols) > 1000:
                        new_symbols = random.sample(new_symbols, 1000)
                    
                    print(f'ğŸ¯ æ–°è¦è¿½åŠ éŠ˜æŸ„æ•°: {len(new_symbols)}')
                    
                    # äºˆç®—å¯¾å¿œï¼š3ã¤ã®ãƒ¢ãƒ‡ãƒ«ã®ã¿
                    models = [
                        {'name': 'LSTM', 'version': 'v1.0', 'confidence': 0.82},
                        {'name': 'STATISTICAL_V2', 'version': 'v2.0', 'confidence': 0.78},
                        {'name': 'ENSEMBLE_V1', 'version': 'v1.0', 'confidence': 0.85}
                    ]
                    
                    # äºˆç®—å¯¾å¿œï¼š8ã¤ã®äºˆæ¸¬æœŸé–“ã®ã¿
                    target_days = [1, 7, 14, 30, 60, 90, 120, 180]
                    
                    total_generated = 0
                    expected_total = len(new_symbols) * len(models) * len(target_days)
                    print(f'ğŸ“Š äºˆæƒ³ç”Ÿæˆæ•°: {expected_total:,}ä»¶')
                    
                    # åŠ¹ç‡çš„ãƒãƒƒãƒå‡¦ç†
                    batch_size = 100
                    for batch_start in range(0, len(new_symbols), batch_size):
                        batch_symbols = new_symbols[batch_start:batch_start + batch_size]
                        print(f'\\nğŸ“Š ãƒãƒƒãƒå‡¦ç†: {len(batch_symbols)}éŠ˜æŸ„')
                        
                        batch_predictions = []
                        
                        for symbol in batch_symbols:
                            # éŠ˜æŸ„ã‚¿ã‚¤ãƒ—åˆ¥åŸºæº–ä¾¡æ ¼
                            if symbol in major_stocks:
                                base_price = 150.0 + np.random.uniform(-50, 150)
                            elif '.T' in symbol:
                                base_price = 2000.0 + np.random.uniform(-500, 2000)
                            elif '-' in symbol:
                                if 'BTC' in symbol:
                                    base_price = 45000.0 + np.random.uniform(-10000, 20000)
                                elif 'ETH' in symbol:
                                    base_price = 2500.0 + np.random.uniform(-500, 1000)
                                else:
                                    base_price = 10.0 + np.random.uniform(-5, 15)
                            else:
                                base_price = 50.0 + np.random.uniform(-20, 80)
                            
                            current_price = base_price
                            
                            for model in models:
                                for days in target_days:
                                    # éŠ˜æŸ„ã‚¿ã‚¤ãƒ—åˆ¥å¤‰å‹•æ€§
                                    if '-' in symbol:
                                        volatility = 0.06 * np.sqrt(days)
                                    elif '.T' in symbol:
                                        volatility = 0.02 * np.sqrt(days)
                                    else:
                                        volatility = 0.03 * np.sqrt(days)
                                    
                                    # ãƒˆãƒ¬ãƒ³ãƒ‰è¨ˆç®—
                                    if model['name'] == 'LSTM':
                                        trend = np.random.uniform(-0.0005, 0.0012) * days
                                    elif model['name'] == 'STATISTICAL_V2':
                                        trend = np.random.uniform(-0.0008, 0.0008) * days
                                    else:
                                        trend = np.random.uniform(-0.0003, 0.0015) * days
                                    
                                    random_factor = np.random.normal(0, volatility)
                                    predicted_price = current_price * (1 + trend + random_factor)
                                    predicted_price = max(0.01, predicted_price)
                                    
                                    confidence = model['confidence'] * np.exp(-days / 200)
                                    confidence = max(0.25, min(0.92, confidence))
                                    
                                    predicted_change = predicted_price - current_price
                                    predicted_change_percent = (predicted_change / current_price) * 100
                                    
                                    batch_predictions.append((
                                        symbol,
                                        datetime.now(),
                                        round(predicted_price, 6),
                                        round(predicted_change, 6),
                                        round(predicted_change_percent, 4),
                                        round(confidence, 4),
                                        model['name'],
                                        model['version'],
                                        days,
                                        True,
                                        f'Budget-friendly batch: {days}d prediction for {symbol}'
                                    ))
                        
                        # ãƒãƒ«ã‚¯ã‚¤ãƒ³ã‚µãƒ¼ãƒˆ
                        insert_sql = '''
                            INSERT INTO stock_predictions (
                                symbol, prediction_date, predicted_price,
                                predicted_change, predicted_change_percent,
                                confidence_score, model_type, model_version,
                                prediction_horizon, is_active, notes
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                        '''
                        
                        cursor.executemany(insert_sql, batch_predictions)
                        connection.commit()
                        
                        total_generated += len(batch_predictions)
                        print(f'  âœ… {len(batch_predictions):,}ä»¶æŒ¿å…¥ (ç´¯è¨ˆ: {total_generated:,})')
                    
                    print('\\n' + '='*60)
                    print('ğŸ’° äºˆç®—å¯¾å¿œæ‹¡å¼µå®Œäº†!')
                    print(f'ğŸ“Š æ–°è¦ç”Ÿæˆ: {total_generated:,}ä»¶')
                    print(f'ğŸ“ˆ æ–°è¦éŠ˜æŸ„: {len(new_symbols)}')
                    
                    # æœ€çµ‚çµ±è¨ˆ
                    cursor.execute('SELECT COUNT(*), COUNT(DISTINCT symbol) FROM stock_predictions')
                    final_predictions, final_symbols = cursor.fetchone()
                    
                    print(f'\\nğŸ† æœ€çµ‚çµ±è¨ˆ:')
                    print(f'  - ç·äºˆæ¸¬æ•°: {final_predictions:,}ä»¶')
                    print(f'  - ç·éŠ˜æŸ„æ•°: {final_symbols:,}')
                    print(f'  - å¹³å‡äºˆæ¸¬/éŠ˜æŸ„: {final_predictions/final_symbols:.1f}ä»¶')
                    
                    connection.close()
                    
                except Exception as e:
                    print(f'âŒ ã‚¨ãƒ©ãƒ¼: {e}')
                    import traceback
                    traceback.print_exc()
                "
      computeResource:
        cpuMilli: "2000"  # 2 CPUï¼ˆäºˆç®—å¯¾å¿œï¼‰
        memoryMib: "8192"  # 8GB RAMï¼ˆäºˆç®—å¯¾å¿œï¼‰
      maxRetryCount: 2
      maxRunDuration: "3600s"  # 1æ™‚é–“
    taskCount: 1
    parallelism: 1

allocationPolicy:
  instances:
    - policy:
        machineType: "e2-standard-2"  # äºˆç®—å¯¾å¿œï¼šå°å‹ãƒã‚·ãƒ³
  location:
    allowedLocations:
      - "regions/us-central1"

logsPolicy:
  destination: "CLOUD_LOGGING"

labels:
  app: "miraikakaku"
  type: "budget-friendly-expansion" 
  environment: "production"
  cost: "optimized"