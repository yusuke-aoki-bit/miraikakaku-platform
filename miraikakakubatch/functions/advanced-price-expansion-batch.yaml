taskGroups:
- name: advanced-price-expansion-workers
  taskSpec:
    runnables:
    - container:
        imageUri: gcr.io/pricewise-huqkr/batch-prediction-generator:latest
        entrypoint: python3
        commands:
        - -c
        - |
          import pymysql
          import requests
          import random
          import time
          import numpy as np
          from datetime import datetime, timedelta
          import os
          import logging
          import json

          # ログ設定
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
          logger = logging.getLogger(__name__)

          worker_id = int(os.getenv('BATCH_TASK_INDEX', '0'))
          total_workers = int(os.getenv('BATCH_TASK_COUNT', '8'))
          logger.info(f"🚀 Advanced Price Expansion Worker {worker_id}/{total_workers} 開始")

          # データベース設定
          db_config = {
              "host": os.getenv('DB_HOST', '34.58.103.36'),
              "user": os.getenv('DB_USER', 'miraikakaku-user'),
              "password": os.getenv('DB_PASSWORD', 'miraikakaku-secure-pass-2024'),
              "database": os.getenv('DB_NAME', 'miraikakaku'),
              "charset": "utf8mb4"
          }

          def get_missing_symbols_for_worker(worker_id, total_workers, limit_per_worker=100):
              """ワーカー別の不足銘柄取得"""
              connection = pymysql.connect(**db_config)
              try:
                  with connection.cursor() as cursor:
                      offset = worker_id * limit_per_worker
                      cursor.execute("""
                          SELECT sm.symbol, sm.name, sm.exchange, sm.country, sm.sector
                          FROM stock_master sm
                          LEFT JOIN (SELECT DISTINCT symbol FROM stock_price_history) sph 
                              ON sm.symbol = sph.symbol
                          WHERE sm.is_active = 1 
                          AND sph.symbol IS NULL
                          ORDER BY sm.symbol
                          LIMIT %s OFFSET %s
                      """, (limit_per_worker, offset))
                      return cursor.fetchall()
              finally:
                  connection.close()

          def generate_comprehensive_synthetic_data(symbol, name, exchange, country, sector, days=90):
              """包括的合成データ生成"""
              try:
                  price_data = []
                  today = datetime.now().date()
                  
                  # 銘柄特性に基づく詳細価格設定
                  if symbol.endswith('=X'):  # 通貨ペア
                      if 'JPY' in symbol:
                          base_price = random.uniform(80, 160)  # USD/JPY範囲
                      else:
                          base_price = random.uniform(0.6, 2.0)  # その他通貨ペア
                      volatility = random.uniform(0.005, 0.015)
                      volume_range = (1000000, 50000000)
                      
                  elif country in ['US', 'United States']:  # 米国株
                      if sector == 'Technology':
                          base_price = random.uniform(50, 500)
                          volatility = random.uniform(0.02, 0.05)
                      elif sector == 'Healthcare':
                          base_price = random.uniform(30, 300)
                          volatility = random.uniform(0.015, 0.035)
                      elif sector == 'Financial':
                          base_price = random.uniform(20, 200)
                          volatility = random.uniform(0.018, 0.04)
                      else:
                          base_price = random.uniform(15, 250)
                          volatility = random.uniform(0.015, 0.04)
                      volume_range = (100000, 10000000)
                      
                  elif country == 'Japan':  # 日本株
                      if sector == 'Technology':
                          base_price = random.uniform(500, 8000)
                          volatility = random.uniform(0.015, 0.035)
                      elif sector == 'Automotive':
                          base_price = random.uniform(300, 5000)
                          volatility = random.uniform(0.012, 0.03)
                      else:
                          base_price = random.uniform(200, 4000)
                          volatility = random.uniform(0.01, 0.03)
                      volume_range = (10000, 5000000)
                      
                  else:  # その他国際株
                      base_price = random.uniform(10, 150)
                      volatility = random.uniform(0.015, 0.04)
                      volume_range = (50000, 3000000)
                  
                  # 時系列データ生成
                  for days_ago in range(1, days + 1):
                      date = today - timedelta(days=days_ago)
                      
                      # 週末スキップ（通貨ペア以外）
                      if not symbol.endswith('=X') and date.weekday() >= 5:
                          continue
                      
                      # より現実的な価格変動シミュレーション
                      # 長期トレンド
                      trend = np.sin(days_ago / 60) * 0.02 + random.gauss(0, 0.005)
                      # 季節性
                      seasonal = np.sin(days_ago / 20) * 0.01
                      # 日次ランダム変動
                      daily_change = random.gauss(0, volatility)
                      
                      total_change = trend + seasonal + daily_change
                      
                      open_price = base_price * (1 + total_change)
                      # イントラデー変動
                      intraday_volatility = volatility * 0.3
                      high_price = open_price * (1 + abs(random.gauss(0, intraday_volatility)))
                      low_price = open_price * (1 - abs(random.gauss(0, intraday_volatility)))
                      close_price = random.uniform(low_price, high_price)
                      
                      # ボリューム（金曜日と月曜日は多め）
                      volume_multiplier = 1.3 if date.weekday() in [0, 4] else 1.0
                      volume = int(random.uniform(*volume_range) * volume_multiplier)
                      
                      price_data.append({
                          'symbol': symbol,
                          'date': date,
                          'open_price': round(max(0.01, open_price), 4),
                          'high_price': round(max(0.01, high_price), 4),
                          'low_price': round(max(0.01, low_price), 4),
                          'close_price': round(max(0.01, close_price), 4),
                          'adjusted_close': round(max(0.01, close_price), 4),
                          'volume': volume,
                          'data_source': f'AdvancedSynthetic_{datetime.now().strftime("%Y%m%d")}_{worker_id}',
                          'is_valid': 1,
                          'data_quality_score': random.uniform(0.88, 0.95)
                      })
                  
                  return price_data
                  
              except Exception as e:
                  logger.error(f"合成データ生成エラー {symbol}: {e}")
                  return None

          def save_price_data_batch(price_data_list):
              """価格データのバッチ保存"""
              if not price_data_list:
                  return 0
                  
              connection = pymysql.connect(**db_config)
              try:
                  with connection.cursor() as cursor:
                      insert_data = []
                      for data in price_data_list:
                          insert_data.append((
                              data['symbol'], data['date'],
                              data['open_price'], data['high_price'], 
                              data['low_price'], data['close_price'],
                              data['volume'], data['adjusted_close'],
                              data['data_source'], data['is_valid'],
                              data['data_quality_score']
                          ))
                      
                      cursor.executemany("""
                          INSERT IGNORE INTO stock_price_history 
                          (symbol, date, open_price, high_price, low_price, close_price, 
                           volume, adjusted_close, data_source, is_valid, data_quality_score, created_at)
                          VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW())
                      """, insert_data)
                      
                      connection.commit()
                      return cursor.rowcount
                      
              except Exception as e:
                  logger.error(f"バッチ保存エラー: {e}")
                  return 0
              finally:
                  connection.close()

          try:
              # ワーカー別不足銘柄取得
              missing_symbols = get_missing_symbols_for_worker(worker_id, total_workers, 100)
              logger.info(f"💫 Worker {worker_id}: {len(missing_symbols)}銘柄の価格データ生成開始")
              
              if not missing_symbols:
                  logger.info(f"⚠️ Worker {worker_id}: 処理対象銘柄なし")
                  exit(0)
              
              total_generated_records = 0
              successful_symbols = 0
              
              for i, (symbol, name, exchange, country, sector) in enumerate(missing_symbols):
                  logger.info(f"📊 Worker {worker_id}: {i+1}/{len(missing_symbols)} - {symbol}")
                  
                  # 包括的合成データ生成
                  price_data = generate_comprehensive_synthetic_data(
                      symbol, name, exchange, country, sector, days=90
                  )
                  
                  if price_data:
                      # データ保存
                      saved_count = save_price_data_batch(price_data)
                      if saved_count > 0:
                          total_generated_records += saved_count
                          successful_symbols += 1
                          logger.info(f"✅ Worker {worker_id}: {symbol} - {saved_count}件保存")
                      else:
                          logger.warning(f"⚠️ Worker {worker_id}: {symbol} - 保存失敗")
                  else:
                      logger.error(f"❌ Worker {worker_id}: {symbol} - 生成失敗")
                  
                  # 進捗報告
                  if (i + 1) % 20 == 0:
                      progress = ((i + 1) / len(missing_symbols)) * 100
                      logger.info(f"📈 Worker {worker_id}: {progress:.0f}% 完了")
                      logger.info(f"   累計: {successful_symbols}銘柄, {total_generated_records:,}件")
              
              logger.info(f"🎯 Worker {worker_id} 完了:")
              logger.info(f"   - 処理銘柄: {len(missing_symbols)}銘柄")
              logger.info(f"   - 成功銘柄: {successful_symbols}銘柄")
              logger.info(f"   - 生成データ: {total_generated_records:,}件")
              logger.info(f"   - 成功率: {(successful_symbols/len(missing_symbols)*100):.1f}%")
              
          except Exception as e:
              logger.error(f"❌ Worker {worker_id} 重大エラー: {e}")
              import traceback
              logger.error(traceback.format_exc())
              exit(1)
      environment:
        variables:
          DB_HOST: "34.58.103.36"
          DB_USER: "miraikakaku-user"
          DB_PASSWORD: "miraikakaku-secure-pass-2024"
          DB_NAME: "miraikakaku"
          PYTHONUNBUFFERED: "1"
    computeResource:
      cpuMilli: 2000
      memoryMib: 4096
    maxRetryCount: 2
    maxRunDuration: 5400s  # 90分
  taskCount: 8
  parallelism: 4
allocationPolicy:
  instances:
  - policy:
      machineType: e2-standard-4
      provisioningModel: STANDARD
  location:
    allowedLocations:
    - regions/us-central1
logsPolicy:
  destination: CLOUD_LOGGING