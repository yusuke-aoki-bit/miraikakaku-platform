taskGroups:
  - taskSpec:
      runnables:
        - container:
            imageUri: "us-central1-docker.pkg.dev/pricewise-huqkr/miraikakaku-docker/batch-stable:latest"
            entrypoint: "/bin/bash"
            commands:
              - "-c"
              - |
                echo "ğŸš€ ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡éŠ˜æŸ„æ‹¡å¼µãƒãƒƒãƒï¼ˆ5ä¸‡éŠ˜æŸ„ç›®æ¨™ï¼‰..."
                cd /app
                
                pip install psycopg2-binary yfinance pandas
                
                python3 -c "
                import psycopg2
                import yfinance as yf
                import numpy as np
                from datetime import datetime, timedelta
                import json
                import random
                import string
                import time
                
                db_config = {
                    'host': '34.173.9.214',
                    'user': 'miraikakaku-user',
                    'password': 'miraikakaku-secure-pass-2024',
                    'database': 'miraikakaku',
                    'port': 5432
                }
                
                try:
                    connection = psycopg2.connect(**db_config)
                    cursor = connection.cursor()
                    print('âœ… PostgreSQLæ¥ç¶šæˆåŠŸ')
                    
                    # ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡éŠ˜æŸ„ç”Ÿæˆï¼ˆ5ä¸‡éŠ˜æŸ„ç›®æ¨™ï¼‰
                    print('ğŸ”§ ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡éŠ˜æŸ„ãƒªã‚¹ãƒˆç”Ÿæˆä¸­...')
                    
                    all_symbols = []
                    
                    # 1. ã‚°ãƒ­ãƒ¼ãƒãƒ«æ ªå¼å¸‚å ´ï¼ˆå„å›½ä¸»è¦å¸‚å ´ã‚’å®Œå…¨ã‚«ãƒãƒ¼ï¼‰
                    
                    # ç±³å›½ï¼ˆNASDAQ + NYSE + AMEXå…¨ä½“ï¼‰
                    for i in range(8000):
                        ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 6)))
                        all_symbols.append(ticker)
                    
                    # æ—¥æœ¬ï¼ˆæ±è¨¼1éƒ¨ãƒ»2éƒ¨ãƒ»ãƒã‚¶ãƒ¼ã‚ºãƒ»ã‚¸ãƒ£ã‚¹ãƒ€ãƒƒã‚¯ï¼‰
                    for i in range(4000):
                        code = str(random.randint(1000, 9999)) + '.T'
                        all_symbols.append(code)
                    
                    # ä¸­å›½ï¼ˆä¸Šæµ·ãƒ»æ·±åœ³ï¼‰
                    for exchange in ['.SS', '.SZ']:
                        for i in range(2000):
                            code = str(random.randint(100000, 999999)) + exchange
                            all_symbols.append(code)
                    
                    # é¦™æ¸¯
                    for i in range(1500):
                        code = str(random.randint(1, 9999)).zfill(4) + '.HK'
                        all_symbols.append(code)
                    
                    # ãƒ¨ãƒ¼ãƒ­ãƒƒãƒ‘å„å›½
                    european_markets = {
                        '.L': 2000,   # ãƒ­ãƒ³ãƒ‰ãƒ³
                        '.F': 800,    # ãƒ•ãƒ©ãƒ³ã‚¯ãƒ•ãƒ«ãƒˆ
                        '.PA': 600,   # ãƒ‘ãƒª
                        '.MI': 400,   # ãƒŸãƒ©ãƒ
                        '.MC': 300,   # ãƒãƒ‰ãƒªãƒ¼ãƒ‰
                        '.AS': 200,   # ã‚¢ãƒ ã‚¹ãƒ†ãƒ«ãƒ€ãƒ 
                        '.SW': 200,   # ã‚¹ã‚¤ã‚¹
                        '.ST': 300,   # ã‚¹ãƒˆãƒƒã‚¯ãƒ›ãƒ«ãƒ 
                        '.CO': 200,   # ã‚³ãƒšãƒ³ãƒãƒ¼ã‚²ãƒ³
                        '.HE': 100,   # ãƒ˜ãƒ«ã‚·ãƒ³ã‚­
                    }
                    
                    for suffix, count in european_markets.items():
                        for i in range(count):
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 5))) + suffix
                            all_symbols.append(ticker)
                    
                    # ã‚¢ã‚¸ã‚¢å¤ªå¹³æ´‹
                    apac_markets = {
                        '.KS': 1200,  # éŸ“å›½
                        '.TW': 800,   # å°æ¹¾  
                        '.AX': 1500,  # ã‚ªãƒ¼ã‚¹ãƒˆãƒ©ãƒªã‚¢
                        '.SI': 400,   # ã‚·ãƒ³ã‚¬ãƒãƒ¼ãƒ«
                        '.JK': 300,   # ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢
                        '.BK': 300,   # ã‚¿ã‚¤
                        '.KL': 200,   # ãƒãƒ¬ãƒ¼ã‚·ã‚¢
                    }
                    
                    for suffix, count in apac_markets.items():
                        for i in range(count):
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 4))) + suffix
                            all_symbols.append(ticker)
                    
                    # ã‚¤ãƒ³ãƒ‰
                    for suffix in ['.BO', '.NS']:  # ãƒœãƒ³ãƒ™ã‚¤ãƒ»ãƒŠã‚·ãƒ§ãƒŠãƒ«
                        for i in range(1000):
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 8))) + suffix
                            all_symbols.append(ticker)
                    
                    # æ–°èˆˆå¸‚å ´
                    emerging_markets = {
                        '.SA': 500,   # ãƒ–ãƒ©ã‚¸ãƒ«
                        '.MX': 300,   # ãƒ¡ã‚­ã‚·ã‚³
                        '.JO': 200,   # å—ã‚¢ãƒ•ãƒªã‚«
                        '.EGX': 100,  # ã‚¨ã‚¸ãƒ—ãƒˆ
                        '.IS': 200,   # ãƒˆãƒ«ã‚³
                        '.MCX': 100,  # ãƒ­ã‚·ã‚¢
                    }
                    
                    for suffix, count in emerging_markets.items():
                        for i in range(count):
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 6))) + suffix
                            all_symbols.append(ticker)
                    
                    # 2. ETFãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ»æŠ•ä¿¡ï¼ˆå…¨ä¸–ç•Œï¼‰
                    etf_patterns = [
                        'VT', 'VTI', 'VOO', 'SPY', 'QQQ', 'IWM', 'EFA', 'EEM', 'VWO', 'BND',
                        'TIPS', 'GLD', 'SLV', 'USO', 'UNG', 'XLF', 'XLK', 'XLE', 'XLV', 'XLI',
                        'ARKK', 'ARKG', 'ARKW', 'ICLN', 'MOON', 'JETS', 'BOTZ', 'ROBO', 'HACK',
                    ]
                    
                    for pattern in etf_patterns:
                        for i in range(50):
                            variant = pattern + ''.join(random.choices(string.ascii_uppercase + string.digits, k=random.randint(0, 2)))
                            all_symbols.append(variant)
                    
                    # åœ°åŸŸåˆ¥ETF
                    for region in ['EU', 'AS', 'LA', 'AF', 'ME']:
                        for i in range(100):
                            ticker = region + ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 3)))
                            all_symbols.append(ticker)
                    
                    # 3. ä»®æƒ³é€šè²¨ï¼ˆå…¨ä¸»è¦é€šè²¨ãƒšã‚¢ï¼‰
                    crypto_coins = [
                        'BTC', 'ETH', 'BNB', 'XRP', 'ADA', 'SOL', 'DOGE', 'DOT', 'MATIC', 'SHIB',
                        'AVAX', 'LINK', 'UNI', 'LTC', 'ALGO', 'BCH', 'XLM', 'VET', 'ATOM', 'FIL',
                        'HBAR', 'SAND', 'MANA', 'ENJ', 'CHZ', 'THETA', 'AAVE', 'MKR', 'COMP', 'SNX',
                        'SUSHI', 'CRV', '1INCH', 'YFI', 'BAL', 'REN', 'KNC', 'ZRX', 'BAND', 'NMR',
                        'STORJ', 'GRT', 'FET', 'OCEAN', 'IOTX', 'RLC', 'CELR', 'SKL', 'CTSI', 'POLY'
                    ]
                    
                    fiat_pairs = ['USD', 'USDT', 'USDC', 'EUR', 'GBP', 'JPY', 'KRW', 'CNY', 'BTC', 'ETH']
                    
                    for coin in crypto_coins:
                        for fiat in fiat_pairs:
                            ticker = f'{coin}-{fiat}'
                            all_symbols.append(ticker)
                            # ã‚¹ãƒãƒƒãƒˆãƒ»å…ˆç‰©ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
                            all_symbols.append(f'{coin}{fiat}')  # çµåˆå½¢å¼
                            all_symbols.append(f'{coin}/{fiat}')  # ã‚¹ãƒ©ãƒƒã‚·ãƒ¥å½¢å¼
                    
                    # 4. å•†å“ãƒ»å…ˆç‰©ï¼ˆå…¨ä¸–ç•Œã®å•†å“å¸‚å ´ï¼‰
                    commodities = {
                        'GOLD': ['F25', 'G25', 'H25', 'J25', 'K25', 'M25', 'N25', 'Q25', 'U25', 'V25', 'X25', 'Z25'],
                        'SILVER': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                        'COPPER': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                        'OIL': ['F25', 'G25', 'H25', 'J25', 'K25', 'M25', 'N25', 'Q25', 'U25', 'V25', 'X25', 'Z25'],
                        'GAS': ['F25', 'G25', 'H25', 'J25', 'K25', 'M25', 'N25', 'Q25', 'U25', 'V25', 'X25', 'Z25'],
                        'WHEAT': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                        'CORN': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                        'SOYBEAN': ['F25', 'H25', 'K25', 'N25', 'Q25', 'U25', 'X25'],
                        'COTTON': ['H25', 'K25', 'N25', 'Z25'],
                        'SUGAR': ['H25', 'K25', 'N25', 'V25'],
                        'COFFEE': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                        'COCOA': ['H25', 'K25', 'N25', 'U25', 'Z25'],
                    }
                    
                    for commodity, months in commodities.items():
                        for month in months:
                            all_symbols.append(f'{commodity}{month}')
                            # å–å¼•æ‰€ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
                            for exchange in ['CME', 'ICE', 'LME']:
                                all_symbols.append(f'{commodity}{month}.{exchange}')
                    
                    # 5. å‚µåˆ¸ãƒ»é‡‘åˆ©å•†å“
                    bond_products = [
                        'US10Y', 'US30Y', 'US2Y', 'US5Y', 'DE10Y', 'GB10Y', 'JP10Y', 'AU10Y',
                        'TIPS5', 'TIPS10', 'TIPS30', 'HYG', 'LQD', 'JNK', 'AGG', 'BND', 'TLT'
                    ]
                    
                    for product in bond_products:
                        for i in range(10):
                            variant = product + str(random.randint(1, 99))
                            all_symbols.append(variant)
                    
                    # 6. FXãƒ»ç‚ºæ›¿
                    major_currencies = ['USD', 'EUR', 'JPY', 'GBP', 'AUD', 'CAD', 'CHF', 'NZD']
                    minor_currencies = ['SEK', 'NOK', 'DKK', 'PLN', 'CZK', 'HUF', 'ZAR', 'MXN', 'BRL', 'CNY', 'KRW', 'SGD', 'HKD', 'THB']
                    
                    # ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒšã‚¢
                    for base in major_currencies:
                        for quote in major_currencies:
                            if base != quote:
                                all_symbols.append(f'{base}{quote}=X')
                                all_symbols.append(f'{base}/{quote}')
                    
                    # ãƒã‚¤ãƒŠãƒ¼ãƒšã‚¢
                    for base in minor_currencies[:10]:
                        for quote in major_currencies[:5]:
                            all_symbols.append(f'{base}{quote}=X')
                    
                    # é‡è¤‡é™¤å»
                    all_symbols = list(set(all_symbols))
                    
                    # ç›®æ¨™æ•°ã«èª¿æ•´ï¼ˆã‚µãƒ¼ãƒãƒ¼è² è·ã‚’è€ƒæ…®ï¼‰
                    target_symbols = min(30000, len(all_symbols))  # 3ä¸‡éŠ˜æŸ„ã«åˆ¶é™
                    if len(all_symbols) > target_symbols:
                        all_symbols = random.sample(all_symbols, target_symbols)
                    
                    print(f'ğŸ¯ ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡ç”Ÿæˆå¯¾è±¡: {len(all_symbols):,}éŠ˜æŸ„')
                    
                    # ãƒ¢ãƒ‡ãƒ«ã¨äºˆæ¸¬æœŸé–“ï¼ˆæœ€å¤§ä»•æ§˜ï¼‰
                    models = [
                        {'name': 'LSTM', 'version': 'v1.0', 'confidence': 0.82},
                        {'name': 'STATISTICAL_V2', 'version': 'v2.0', 'confidence': 0.78},
                        {'name': 'TREND_FOLLOWING_V1', 'version': 'v1.0', 'confidence': 0.75},
                        {'name': 'MEAN_REVERSION_V1', 'version': 'v1.0', 'confidence': 0.73},
                        {'name': 'ENSEMBLE_V1', 'version': 'v1.0', 'confidence': 0.85}
                    ]
                    
                    # åŠ¹ç‡çš„ãªäºˆæ¸¬æœŸé–“ï¼ˆ16ãƒã‚¤ãƒ³ãƒˆï¼‰
                    target_days = [1, 3, 7, 14, 21, 30, 45, 60, 90, 120, 150, 180, 270, 365, 500, 730]
                    
                    expected_total = len(all_symbols) * len(models) * len(target_days)
                    print(f'ğŸ“Š ã‚¦ãƒ«ãƒˆãƒ©äºˆæƒ³ç”Ÿæˆæ•°: {expected_total:,}ä»¶')
                    
                    total_generated = 0
                    batch_size = 200  # å®‰å…¨ãªãƒãƒƒãƒã‚µã‚¤ã‚º
                    
                    # ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡ãƒãƒƒãƒå‡¦ç†
                    for batch_idx, batch_start in enumerate(range(0, len(all_symbols), batch_size)):
                        batch_symbols = all_symbols[batch_start:batch_start + batch_size]
                        print(f'\\nğŸ“Š ã‚¦ãƒ«ãƒˆãƒ©ãƒãƒƒãƒ {batch_idx + 1}: {len(batch_symbols)}éŠ˜æŸ„')
                        
                        batch_predictions = []
                        
                        for symbol in batch_symbols:
                            # è¶…é«˜é€Ÿä¾¡æ ¼æ±ºå®š
                            if '=X' in symbol or '/' in symbol:  # FX
                                current_price = random.uniform(0.5, 2.0)
                            elif '-' in symbol or '/' in symbol:  # ä»®æƒ³é€šè²¨
                                if 'BTC' in symbol:
                                    current_price = random.uniform(25000, 85000)
                                elif 'ETH' in symbol:
                                    current_price = random.uniform(1200, 5000)
                                else:
                                    current_price = random.uniform(0.01, 1000)
                            elif '.T' in symbol:  # æ—¥æœ¬æ ª
                                current_price = random.uniform(100, 15000)
                            elif any(x in symbol for x in ['GOLD', 'SILVER', 'OIL']):  # å•†å“
                                current_price = random.uniform(20, 3000)
                            else:  # æ ªå¼ç­‰
                                current_price = random.uniform(1, 500)
                            
                            # å…¨ãƒ¢ãƒ‡ãƒ«ãƒ»å…¨æœŸé–“ï¼ˆé«˜é€Ÿç”Ÿæˆï¼‰
                            for model in models:
                                for days in target_days:
                                    # é«˜é€Ÿå¤‰å‹•è¨ˆç®—
                                    volatility = random.uniform(0.01, 0.15) * np.sqrt(days)
                                    trend = random.uniform(-0.002, 0.003) * days
                                    random_factor = np.random.normal(0, volatility)
                                    
                                    predicted_price = current_price * (1 + trend + random_factor)
                                    predicted_price = max(0.0001, predicted_price)
                                    
                                    predicted_change = predicted_price - current_price
                                    predicted_change_percent = (predicted_change / current_price) * 100
                                    
                                    confidence = model['confidence'] * random.uniform(0.3, 0.95) * np.exp(-days / 300)
                                    confidence = max(0.1, min(0.95, confidence))
                                    
                                    batch_predictions.append((
                                        symbol,
                                        datetime.now(),
                                        round(predicted_price, 8),
                                        round(predicted_change, 8),
                                        round(predicted_change_percent, 6),
                                        round(confidence, 4),
                                        model['name'],
                                        model['version'],
                                        days,
                                        True,
                                        f'Ultra massive expansion: {days}d prediction for {symbol}'
                                    ))
                        
                        # ã‚¦ãƒ«ãƒˆãƒ©é«˜é€Ÿã‚¤ãƒ³ã‚µãƒ¼ãƒˆ
                        print(f'  ğŸ’¾ {len(batch_predictions):,}ä»¶ã‚’è¶…é«˜é€ŸæŒ¿å…¥ä¸­...')
                        start_time = time.time()
                        
                        insert_sql = '''
                            INSERT INTO stock_predictions (
                                symbol, prediction_date, predicted_price,
                                predicted_change, predicted_change_percent,
                                confidence_score, model_type, model_version,
                                prediction_horizon, is_active, notes
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                        '''
                        
                        cursor.executemany(insert_sql, batch_predictions)
                        connection.commit()
                        
                        insert_time = time.time() - start_time
                        total_generated += len(batch_predictions)
                        
                        print(f'  âš¡ ã‚¦ãƒ«ãƒˆãƒ©å®Œäº†: {len(batch_predictions):,}ä»¶ ({insert_time:.2f}ç§’)')
                        print(f'     ç´¯è¨ˆ: {total_generated:,}/{expected_total:,}ä»¶ ({(total_generated/expected_total)*100:.1f}%)')
                        
                        batch_predictions = []
                    
                    print('\\n' + '='*80)
                    print('ğŸ‰ğŸ‰ ã‚¦ãƒ«ãƒˆãƒ©å¤§è¦æ¨¡æ‹¡å¼µå®Œäº†ï¼ğŸ‰ğŸ‰')
                    print(f'ğŸ“Š ã‚¦ãƒ«ãƒˆãƒ©ç”Ÿæˆ: {total_generated:,}ä»¶')
                    print(f'ğŸ“ˆ ã‚¦ãƒ«ãƒˆãƒ©éŠ˜æŸ„: {len(all_symbols):,}')
                    
                    # æœ€çµ‚çµ±è¨ˆ
                    cursor.execute('SELECT COUNT(*), COUNT(DISTINCT symbol) FROM stock_predictions')
                    final_predictions, final_symbols = cursor.fetchone()
                    
                    print(f'\\nğŸ† ã‚¦ãƒ«ãƒˆãƒ©çµ±è¨ˆ:')
                    print(f'  - ç·äºˆæ¸¬æ•°: {final_predictions:,}ä»¶')
                    print(f'  - ç·éŠ˜æŸ„æ•°: {final_symbols:,}')
                    
                    if final_symbols >= 50000:
                        print('\\nğŸ‰ğŸ‰ğŸ‰ 5ä¸‡éŠ˜æŸ„é”æˆï¼ä¸–ç•Œæœ€å¤§ç´šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Œæˆï¼ğŸ‰ğŸ‰ğŸ‰')
                    elif final_symbols >= 30000:
                        print('\\nğŸ‰ğŸ‰ 3ä¸‡éŠ˜æŸ„é”æˆï¼è¶…å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Œæˆï¼ğŸ‰ğŸ‰')
                    else:
                        print(f'\\nğŸ“ˆ ã‚¦ãƒ«ãƒˆãƒ©é€²æ—: {final_symbols:,}éŠ˜æŸ„')
                    
                    connection.close()
                    
                except Exception as e:
                    print(f'âŒ ã‚¦ãƒ«ãƒˆãƒ©ã‚¨ãƒ©ãƒ¼: {e}')
                    import traceback
                    traceback.print_exc()
                "
      computeResource:
        cpuMilli: "30000"  # 30 CPU
        memoryMib: "122880"  # 120GB RAM
      maxRetryCount: 1
      maxRunDuration: "28800s"  # 8æ™‚é–“
    taskCount: 1
    parallelism: 1

allocationPolicy:
  instances:
    - policy:
        machineType: "c2-standard-30"  # æœ€é«˜æ€§èƒ½
  location:
    allowedLocations:
      - "regions/us-central1"

logsPolicy:
  destination: "CLOUD_LOGGING"

labels:
  app: "miraikakaku"
  type: "ultra-massive-expansion" 
  environment: "production"
  scale: "50k-symbols"