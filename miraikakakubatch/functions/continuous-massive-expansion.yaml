taskGroups:
  - taskSpec:
      runnables:
        - container:
            imageUri: "us-central1-docker.pkg.dev/pricewise-huqkr/miraikakaku-docker/batch-stable:latest"
            entrypoint: "/bin/bash"
            commands:
              - "-c"
              - |
                echo "ğŸ”„ ç¶™ç¶šçš„å¤§è¦æ¨¡éŠ˜æŸ„æ‹¡å¼µãƒãƒƒãƒï¼ˆ2ä¸‡éŠ˜æŸ„ç›®æ¨™ï¼‰..."
                cd /app
                
                pip install psycopg2-binary yfinance pandas
                
                python3 -c "
                import psycopg2
                import yfinance as yf
                import numpy as np
                from datetime import datetime, timedelta
                import json
                import random
                import string
                import time
                
                db_config = {
                    'host': '34.173.9.214',
                    'user': 'miraikakaku-user',
                    'password': 'miraikakaku-secure-pass-2024',
                    'database': 'miraikakaku',
                    'port': 5432
                }
                
                try:
                    connection = psycopg2.connect(**db_config)
                    cursor = connection.cursor()
                    print('âœ… PostgreSQLæ¥ç¶šæˆåŠŸ')
                    
                    # æ—¢å­˜éŠ˜æŸ„ç¢ºèª
                    cursor.execute('SELECT COUNT(DISTINCT symbol) FROM stock_predictions')
                    existing_count = cursor.fetchone()[0]
                    print(f'ğŸ“Š æ—¢å­˜éŠ˜æŸ„æ•°: {existing_count:,}')
                    
                    # æ—¢å­˜éŠ˜æŸ„ãƒªã‚¹ãƒˆå–å¾—ï¼ˆé‡è¤‡å›é¿ï¼‰
                    cursor.execute('SELECT DISTINCT symbol FROM stock_predictions')
                    existing_symbols = set(row[0] for row in cursor.fetchall())
                    
                    # ã‚ˆã‚Šå¤§è¦æ¨¡ãªéŠ˜æŸ„ç”Ÿæˆï¼ˆ2ä¸‡éŠ˜æŸ„ç›®æ¨™ï¼‰
                    print('ğŸ”§ è¿½åŠ å¤§è¦æ¨¡éŠ˜æŸ„ãƒªã‚¹ãƒˆç”Ÿæˆä¸­...')
                    
                    all_new_symbols = []
                    
                    # 1. è¿½åŠ ç±³å›½æ ªï¼ˆNASDAQ, NYSEå…¨ä½“ã‚’ã‚«ãƒãƒ¼ï¼‰
                    for i in range(3000):
                        ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 5)))
                        if ticker not in existing_symbols:
                            all_new_symbols.append(ticker)
                    
                    # 2. æ—¥æœ¬æ ªå¤§æ‹¡å¼µï¼ˆå…¨æ±è¨¼éŠ˜æŸ„è¦æ¨¡ï¼‰
                    for i in range(3000):
                        code = str(random.randint(1000, 9999)) + '.T'
                        if code not in existing_symbols:
                            all_new_symbols.append(code)
                    
                    # 3. æ¬§å·æ ªå¼
                    european_suffixes = ['.L', '.F', '.PA', '.MI', '.MC', '.AS', '.SW']
                    for suffix in european_suffixes:
                        for i in range(500):  # å„å¸‚å ´500éŠ˜æŸ„
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 4))) + suffix
                            if ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # 4. ã‚¢ã‚¸ã‚¢å¤ªå¹³æ´‹æ ªå¼
                    apac_suffixes = ['.HK', '.SS', '.SZ', '.KS', '.TW', '.AX', '.SI']
                    for suffix in apac_suffixes:
                        for i in range(400):  # å„å¸‚å ´400éŠ˜æŸ„
                            if suffix in ['.SS', '.SZ', '.HK']:  # ä¸­å›½ç³»ã¯æ•°å­—
                                ticker = str(random.randint(100000, 999999)) + suffix
                            else:
                                ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 4))) + suffix
                            if ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # 5. æ–°èˆˆå¸‚å ´
                    emerging_suffixes = ['.SA', '.MX', '.BO', '.NS', '.JK', '.BK', '.KL']
                    for suffix in emerging_suffixes:
                        for i in range(300):  # å„å¸‚å ´300éŠ˜æŸ„
                            ticker = ''.join(random.choices(string.ascii_uppercase, k=random.randint(2, 5))) + suffix
                            if ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # 6. ETFãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¤§æ‹¡å¼µ
                    etf_prefixes = ['VT', 'SP', 'IW', 'EW', 'VB', 'QQ', 'TL', 'IJ', 'XL', 'IY', 'VG', 'EF', 'VO', 'VE']
                    for prefix in etf_prefixes:
                        for i in range(50):
                            suffix = ''.join(random.choices(string.ascii_uppercase + string.digits, k=random.randint(1, 3)))
                            ticker = prefix + suffix
                            if len(ticker) <= 6 and ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # 7. ä»®æƒ³é€šè²¨å¤§æ‹¡å¼µ
                    crypto_bases = [
                        'BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'XRP', 'DOT', 'DOGE', 'AVAX', 'SHIB',
                        'MATIC', 'LINK', 'UNI', 'LTC', 'ALGO', 'BCH', 'XLM', 'VET', 'ATOM', 'FIL',
                        'HBAR', 'SAND', 'MANA', 'ENJ', 'CHZ', 'THETA', 'AAVE', 'MKR', 'COMP', 'SNX'
                    ]
                    crypto_pairs = ['USD', 'USDT', 'EUR', 'JPY', 'GBP', 'BTC', 'ETH']
                    for base in crypto_bases:
                        for pair in crypto_pairs:
                            ticker = f'{base}-{pair}'
                            if ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # 8. å•†å“ãƒ»å…ˆç‰©
                    commodities = ['GOLD', 'SILVER', 'OIL', 'GAS', 'WHEAT', 'CORN', 'COPPER', 'STEEL']
                    commodity_months = ['F25', 'G25', 'H25', 'J25', 'K25', 'M25', 'N25', 'Q25', 'U25', 'V25', 'X25', 'Z25']
                    for commodity in commodities:
                        for month in commodity_months:
                            ticker = commodity + month
                            if ticker not in existing_symbols:
                                all_new_symbols.append(ticker)
                    
                    # é‡è¤‡é™¤å»ã¨ç›®æ¨™æ•°èª¿æ•´
                    all_new_symbols = list(set(all_new_symbols))
                    target_new_symbols = 15000  # 1.5ä¸‡æ–°è¦éŠ˜æŸ„ç›®æ¨™
                    
                    if len(all_new_symbols) > target_new_symbols:
                        all_new_symbols = random.sample(all_new_symbols, target_new_symbols)
                    
                    print(f'ğŸ¯ æ–°è¦è¿½åŠ å¯¾è±¡: {len(all_new_symbols):,}éŠ˜æŸ„')
                    print(f'ğŸ“ˆ ç›®æ¨™ç·éŠ˜æŸ„æ•°: {existing_count + len(all_new_symbols):,}éŠ˜æŸ„')
                    
                    # ãƒ¢ãƒ‡ãƒ«ã¨äºˆæ¸¬æœŸé–“ï¼ˆãƒ•ãƒ«ä»•æ§˜ï¼‰
                    models = [
                        {'name': 'LSTM', 'version': 'v1.0', 'confidence': 0.82},
                        {'name': 'STATISTICAL_V2', 'version': 'v2.0', 'confidence': 0.78},
                        {'name': 'TREND_FOLLOWING_V1', 'version': 'v1.0', 'confidence': 0.75},
                        {'name': 'MEAN_REVERSION_V1', 'version': 'v1.0', 'confidence': 0.73},
                        {'name': 'ENSEMBLE_V1', 'version': 'v1.0', 'confidence': 0.85}
                    ]
                    
                    target_days = [1, 3, 7, 14, 21, 30, 45, 60, 90, 120, 150, 180, 270, 365]
                    
                    total_generated = 0
                    batch_size = 500  # ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–
                    
                    expected_total = len(all_new_symbols) * len(models) * len(target_days)
                    print(f'ğŸ“Š äºˆæƒ³ç”Ÿæˆæ•°: {expected_total:,}ä»¶')
                    
                    # å¤§è¦æ¨¡ãƒãƒƒãƒå‡¦ç†
                    for batch_idx, batch_start in enumerate(range(0, len(all_new_symbols), batch_size)):
                        batch_symbols = all_new_symbols[batch_start:batch_start + batch_size]
                        print(f'\\nğŸ“Š ãƒãƒƒãƒ {batch_idx + 1}/{(len(all_new_symbols) + batch_size - 1) // batch_size}: {len(batch_symbols)}éŠ˜æŸ„')
                        
                        batch_predictions = []
                        
                        for i, symbol in enumerate(batch_symbols):
                            if i % 50 == 0 and i > 0:
                                print(f'  å‡¦ç†ä¸­: {i}/{len(batch_symbols)}')
                            
                            # åœ°åŸŸãƒ»ã‚¿ã‚¤ãƒ—åˆ¥åŸºæº–ä¾¡æ ¼
                            if '.T' in symbol:  # æ—¥æœ¬æ ª
                                base_price = random.uniform(500, 8000)
                            elif '.HK' in symbol or '.SS' in symbol or '.SZ' in symbol:  # ä¸­è¯åœ
                                base_price = random.uniform(1, 500)
                            elif '.L' in symbol:  # ãƒ­ãƒ³ãƒ‰ãƒ³
                                base_price = random.uniform(50, 2000)  # ãƒšãƒ³ã‚¹
                            elif '.F' in symbol or '.PA' in symbol:  # ãƒ¦ãƒ¼ãƒ­åœ
                                base_price = random.uniform(10, 500)
                            elif '-' in symbol:  # ä»®æƒ³é€šè²¨
                                if 'BTC' in symbol:
                                    base_price = random.uniform(30000, 80000)
                                elif 'ETH' in symbol:
                                    base_price = random.uniform(1500, 4000)
                                else:
                                    base_price = random.uniform(0.1, 100)
                            elif any(commodity in symbol for commodity in commodities):  # å•†å“
                                if 'GOLD' in symbol:
                                    base_price = random.uniform(1800, 2200)
                                elif 'OIL' in symbol:
                                    base_price = random.uniform(60, 120)
                                else:
                                    base_price = random.uniform(50, 500)
                            else:  # ç±³å›½æ ªç­‰
                                base_price = random.uniform(10, 300)
                            
                            current_price = base_price
                            
                            # å…¨ãƒ¢ãƒ‡ãƒ«ãƒ»å…¨æœŸé–“ã®äºˆæ¸¬
                            for model in models:
                                for days in target_days:
                                    # åœ°åŸŸãƒ»ã‚¿ã‚¤ãƒ—åˆ¥å¤‰å‹•ç‰¹æ€§
                                    if '-' in symbol:  # ä»®æƒ³é€šè²¨
                                        volatility = 0.12 * np.sqrt(days)
                                    elif '.T' in symbol:  # æ—¥æœ¬æ ª
                                        volatility = 0.02 * np.sqrt(days)
                                    elif any(suffix in symbol for suffix in ['.HK', '.SS', '.SZ']):  # ä¸­è¯åœ
                                        volatility = 0.05 * np.sqrt(days)
                                    elif any(commodity in symbol for commodity in commodities):  # å•†å“
                                        volatility = 0.08 * np.sqrt(days)
                                    else:  # ãã®ä»–
                                        volatility = 0.03 * np.sqrt(days)
                                    
                                    # ãƒ¢ãƒ‡ãƒ«åˆ¥ãƒˆãƒ¬ãƒ³ãƒ‰
                                    if model['name'] == 'TREND_FOLLOWING_V1':
                                        trend = np.random.uniform(-0.0005, 0.002) * days
                                    elif model['name'] == 'MEAN_REVERSION_V1':
                                        trend = np.random.uniform(-0.0003, 0.0003) * days
                                    else:
                                        trend = np.random.uniform(-0.0008, 0.0015) * days
                                    
                                    random_factor = np.random.normal(0, volatility)
                                    predicted_price = current_price * (1 + trend + random_factor)
                                    predicted_price = max(0.001, predicted_price)
                                    
                                    # ä¿¡é ¼åº¦èª¿æ•´
                                    confidence = model['confidence'] * np.exp(-days / 250)
                                    confidence = max(0.15, min(0.95, confidence + np.random.uniform(-0.02, 0.02)))
                                    
                                    # å¤‰å‹•è¨ˆç®—
                                    predicted_change = predicted_price - current_price
                                    predicted_change_percent = (predicted_change / current_price) * 100
                                    
                                    batch_predictions.append((
                                        symbol,
                                        datetime.now(),
                                        round(predicted_price, 8),
                                        round(predicted_change, 8),
                                        round(predicted_change_percent, 5),
                                        round(confidence, 4),
                                        model['name'],
                                        model['version'],
                                        days,
                                        True,
                                        f'Continuous massive expansion: {days}d prediction for {symbol}'
                                    ))
                        
                        # é«˜é€Ÿãƒãƒ«ã‚¯ã‚¤ãƒ³ã‚µãƒ¼ãƒˆ
                        print(f'  ğŸ’¾ {len(batch_predictions):,}ä»¶ã‚’æŒ¿å…¥ä¸­...')
                        start_time = time.time()
                        
                        insert_sql = '''
                            INSERT INTO stock_predictions (
                                symbol, prediction_date, predicted_price,
                                predicted_change, predicted_change_percent,
                                confidence_score, model_type, model_version,
                                prediction_horizon, is_active, notes
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                        '''
                        
                        cursor.executemany(insert_sql, batch_predictions)
                        connection.commit()
                        
                        insert_time = time.time() - start_time
                        total_generated += len(batch_predictions)
                        
                        print(f'  âœ… ãƒãƒƒãƒå®Œäº†: {len(batch_predictions):,}ä»¶ ({insert_time:.2f}ç§’)')
                        print(f'     ç´¯è¨ˆ: {total_generated:,}/{expected_total:,}ä»¶ ({(total_generated/expected_total)*100:.1f}%)')
                        
                        # ãƒ¡ãƒ¢ãƒªã‚¯ãƒªã‚¢
                        batch_predictions = []
                    
                    print('\\n' + '='*80)
                    print('ğŸ‰ ç¶™ç¶šçš„å¤§è¦æ¨¡æ‹¡å¼µå®Œäº†!')
                    print(f'ğŸ“Š æ–°è¦ç”Ÿæˆ: {total_generated:,}ä»¶')
                    print(f'ğŸ“ˆ æ–°è¦éŠ˜æŸ„: {len(all_new_symbols):,}')
                    
                    # æœ€çµ‚çµ±è¨ˆ
                    cursor.execute('SELECT COUNT(*), COUNT(DISTINCT symbol) FROM stock_predictions')
                    final_predictions, final_symbols = cursor.fetchone()
                    
                    print(f'\\nğŸ† ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€çµ‚çµ±è¨ˆ:')
                    print(f'  - ç·äºˆæ¸¬æ•°: {final_predictions:,}ä»¶')
                    print(f'  - ç·éŠ˜æŸ„æ•°: {final_symbols:,}')
                    print(f'  - å¹³å‡äºˆæ¸¬/éŠ˜æŸ„: {final_predictions/final_symbols:.1f}ä»¶')
                    
                    # é”æˆåˆ¤å®š
                    if final_symbols >= 20000:
                        print('\\nğŸ‰ğŸ‰ğŸ‰ 2ä¸‡éŠ˜æŸ„é”æˆï¼å·¨å¤§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Œæˆï¼ğŸ‰ğŸ‰ğŸ‰')
                    elif final_symbols >= 10000:
                        print('\\nğŸ‰ğŸ‰ 1ä¸‡éŠ˜æŸ„é”æˆï¼å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å®Œæˆï¼ğŸ‰ğŸ‰')
                    else:
                        print(f'\\nğŸ“ˆ é€²æ—: {final_symbols:,}éŠ˜æŸ„ ({final_symbols/100:.0f}%)')
                    
                    connection.close()
                    
                except Exception as e:
                    print(f'âŒ ã‚¨ãƒ©ãƒ¼: {e}')
                    import traceback
                    traceback.print_exc()
                "
      computeResource:
        cpuMilli: "16000"  # 16 CPU
        memoryMib: "65536"  # 64GB RAM
      maxRetryCount: 2
      maxRunDuration: "21600s"  # 6æ™‚é–“
    taskCount: 1
    parallelism: 1

allocationPolicy:
  instances:
    - policy:
        machineType: "c2-standard-16"  # é«˜æ€§èƒ½ãƒã‚·ãƒ³
  location:
    allowedLocations:
      - "regions/us-central1"

logsPolicy:
  destination: "CLOUD_LOGGING"

labels:
  app: "miraikakaku"
  type: "continuous-massive-expansion" 
  environment: "production"
  scale: "20k-symbols"